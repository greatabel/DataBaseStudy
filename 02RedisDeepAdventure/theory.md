@ Redis是个单线程程序，其实node.js/Nginx也是单线程
 Rdis单线程还快的原因是：所有数据在内存，所有运算是内存级别的运算。

@ Redis单线程，怎么处理那么多并发客户端链接？
    非阻塞IO  在套接字对象提供一个选项Non_blocking，读写方法不会阻塞。能读多少取决于内核为套接字
分配的读缓冲区的数据字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲字节数。读写都通过返回值
告知程序实际读写多少字节。
    非阻塞IO的问题就是：线程如何知道何时才应该继续读，何时才应该继续写

    事件轮询API（多路复用）是解决这个的
    最简单的事件轮询 API是select函数，它是操作系统提供给用户程序的API
我们通过select系统调用同时处理多个通道描述符符的读写事件，这类系统成为多路复用API
现代操作系统多路复用API不再是select系统调用，而改用epoll(linux)和 kqueue(freebsd macOSX) 
windows的IOCP
    时间轮询API就是Java里面的NIO技术（Non-blocking I/O，在Java领域，也称为New I/O）
    而在Python3.4 中新增了 selectors 模块，用于封装各个操作系统所提供的 I/O 多路复用的接口

@
最大—最小堆：是最大层和最小层交替出现的二叉树，即最大层结点的子节点属于最小层，最小层结点的子节点属于最大层。 以最大（小）层结n点为根结点的子树保有最大（小）堆性质：根结点的键值为该子树结点键值中最大（小）项。

redis的定时任务会记录在“最小堆”中，最快要执行的任务排在堆的最上方。每个循环周期，redis都会对最小堆里面
已经到了时间点到任务进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的
timeout参数。

@ redis作者认为数据库系统的瓶颈不在于网络流量，而在于数据库自身内部逻辑处理上。
Redis用一个单线程对外提供服务，单个节点跑慢一个CPU可以倒倒10w/s的QPS

RESP是Redis的序列化协议(Redis Serializaiton Protocol)
协议还有大量冗余的回车换行符，优势在于：实现过程异常简单，解析性能极好

@ Redis持久化有2种：一种是快照（全量备份 snapshotting)，一种是AOF日志(增量备份，即Append Only File持久化)

redis使用操作系统多进程COW (copy on write)机制实现快照持久化
Redis在持久化时候会调用glibc函数fork一个子进程。子进程不会修改现有内存数据结构，只是遍历读取，然后序列化到磁盘
父进程继续持续服务客户端请求，然后对内存数据结构不间断修改。
子进程看到的内存数据是进程产生的一瞬间就凝固了，不会改变。

AOF是文件形式存在
linux的glibc提供了fsync(int fd)将制定文件内容从内存缓存到磁盘
但fsync是磁盘io，所以生产环节，一般每隔1s执行fsync，安全性和性能的折中
Redis也提供了另外2种策略：用不调用fsync--让操作系统决定何时同步磁盘，另一种
是来一个指令调用一次fsync(非常慢)


@redis主节点一般不会进行持久化，主要在从节点进行。

redis4 带来：混合持久化。这里AOF日志不再是全量，而是自持久化开始到持久化结束
时间段发生的增量AOF日志，通常很小

@ redis事务指令为: 
multi, 指示事务开始
exec, 事务执行
discard 事务丢弃
客户端执行事务都会结合pipeline 使用

@ redis不支持回滚？
Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），
或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，
失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，
而不应该出现在生产环境中。
因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速

鉴于没有任何机制能避免程序员自己造成的错误， 
并且这类错误通常不会在生产环境中出现， 
所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。


@ 为了支持消息多播，redis使用一个PubSub模块支持消息多播
缺点：redis停机，消息不会持久化。所以redis作者独立开了disque专门做多播。
Redis 5.0 增加了stream数据结构，带来了持久化的消息队列

@ redis并不总是将空闲内存立即归还操作系统
    虽然无法保证回收已经删除了key内存，但是它会重新使用哪些未被回收的空闲内存

  redis把内存分配丢给第三方内存分配库, 目前使用 jemalloc( facebook)
   也可以切换到tcmalloc( google)库




